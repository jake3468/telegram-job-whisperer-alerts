
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { logger } from '@/utils/logger';

const SUPABASE_URL = "https://fnzloyyhzhrqsvslhhri.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZuemxveXloemhycXN2c2xoaHJpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5MzAyMjIsImV4cCI6MjA2NDUwNjIyMn0.xdlgb_amJ1fV31uinCFotGW00isgT5-N8zJ_gLHEKuk";

// Validate required environment variables
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  throw new Error('Missing required Supabase configuration. Please check your environment variables.');
}

// Store the current JWT token and refresh function
let currentJWTToken: string | null = null;
let tokenRefreshFunction: (() => Promise<string | null>) | null = null;

// Create a single Supabase client instance to prevent multiple client warnings
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: false,
    autoRefreshToken: true,
    detectSessionInUrl: false,
    storage: typeof window !== 'undefined' ? window.localStorage : undefined,
  },
  global: {
    headers: {}
  }
});

// Function to set token refresh function from Clerk
export const setTokenRefreshFunction = (refreshFn: () => Promise<string | null>) => {
  tokenRefreshFunction = refreshFn;
  logger.debug('Token refresh function set');
};

// Function to refresh JWT token
export const refreshJWTToken = async (): Promise<string | null> => {
  try {
    if (!tokenRefreshFunction) {
      logger.warn('No token refresh function available');
      return null;
    }

    logger.debug('Refreshing JWT token...');
    const newToken = await tokenRefreshFunction();
    
    if (newToken) {
      currentJWTToken = newToken;
      logger.debug('JWT token refreshed successfully');
      return newToken;
    } else {
      logger.warn('Failed to refresh JWT token');
      return null;
    }
  } catch (error) {
    logger.error('Error refreshing JWT token:', error);
    return null;
  }
};

// Function to check if token is expired
const isTokenExpired = (token: string): boolean => {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return true;
    
    const payload = JSON.parse(atob(parts[1]));
    const now = Math.floor(Date.now() / 1000);
    const buffer = 60; // 60 seconds buffer before expiration
    
    return payload.exp && (payload.exp - buffer) < now;
  } catch (e) {
    return true;
  }
};

// Function to set Clerk JWT token  
export const setClerkToken = async (token: string | null) => {
  try {
    logger.debug('Setting Clerk JWT token...');
    
    if (token) {
      // Validate token format before setting
      const parts = token.split('.');
      if (parts.length !== 3) {
        logger.error('Invalid JWT format - token does not have 3 parts');
        return false;
      }

      // Try to decode the payload to validate
      try {
        const payload = JSON.parse(atob(parts[1]));
        logger.debug('JWT payload validated', logger.sanitizeForLog({
          sub: payload.sub,
          iss: payload.iss,
          aud: payload.aud,
          exp: payload.exp,
          iat: payload.iat,
          role: payload.role
        }));
        
        // Check if token is expired
        const now = Math.floor(Date.now() / 1000);
        if (payload.exp && payload.exp < now) {
          logger.warn('JWT token is already expired');
          return false;
        }
      } catch (e) {
        logger.warn('Could not decode JWT payload for validation:', e);
      }

      currentJWTToken = token;
      logger.debug('Clerk JWT token stored');
      return true;
    } else {
      currentJWTToken = null;
      logger.debug('Clerk JWT token cleared');
      return true;
    }
  } catch (error) {
    logger.error('Error setting Clerk JWT token:', error);
    return false;
  }
};

// Function to get current JWT token for debugging
export const getCurrentJWTToken = () => currentJWTToken;

// Enhanced function to make authenticated requests with automatic token refresh
export const makeAuthenticatedRequest = async <T>(
  operation: () => Promise<T>,
  operationType: string = 'unknown',
  maxRetries: number = 2
): Promise<T> => {
  let lastError: any = null;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // Check if we need to refresh the token
      if (currentJWTToken && isTokenExpired(currentJWTToken)) {
        logger.debug(`Token expired, refreshing before ${operationType}...`);
        await refreshJWTToken();
      }

      if (!currentJWTToken) {
        logger.warn(`No JWT token available for ${operationType} (attempt ${attempt + 1})`);
      } else {
        logger.debug(`Making authenticated request for: ${operationType} (attempt ${attempt + 1})`);
      }
      
      // Create a new client instance with JWT headers for this specific request
      if (currentJWTToken) {
        const authenticatedClient = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
          auth: {
            persistSession: false,
            autoRefreshToken: true,
          },
          global: {
            headers: {
              'Authorization': `Bearer ${currentJWTToken}`
            }
          }
        });

        logger.debug(`Using authenticated client for ${operationType} (attempt ${attempt + 1})`);
        
        // Replace the global supabase instance temporarily for this operation
        const originalFrom = supabase.from.bind(supabase);
        const originalRpc = supabase.rpc.bind(supabase);
        
        // Override methods to use authenticated client
        (supabase as any).from = authenticatedClient.from.bind(authenticatedClient);
        (supabase as any).rpc = authenticatedClient.rpc.bind(authenticatedClient);
        
        try {
          const result = await operation();
          return result;
        } finally {
          // Restore original methods
          (supabase as any).from = originalFrom;
          (supabase as any).rpc = originalRpc;
        }
      }
      
      return await operation();
    } catch (error: any) {
      lastError = error;
      logger.error(`Attempt ${attempt + 1} failed for ${operationType}:`, error);
      
      // If it's a JWT expired error, try to refresh token and retry
      if ((error?.code === 'PGRST301' || error?.message?.includes('JWT expired')) && attempt < maxRetries - 1) {
        logger.debug(`JWT expired, attempting token refresh...`);
        const refreshed = await refreshJWTToken();
        if (refreshed) {
          logger.debug(`Token refreshed, retrying in 1000ms...`);
          await new Promise(resolve => setTimeout(resolve, 1000));
          continue;
        }
      }
      
      // For other errors, don't retry unless it's the first attempt and token-related
      if (!error?.message?.includes('JWT expired') && !error?.code?.includes('PGRST301')) {
        throw error;
      }
    }
  }
  
  // If we've exhausted all retries, throw the last error
  throw lastError;
};

// Function to test JWT transmission with direct RPC call
export const testJWTTransmission = async () => {
  try {
    logger.debug('Testing JWT transmission with authenticated client...');
    logger.debug('Current token available:', currentJWTToken ? 'YES' : 'NO');
    
    // Make direct RPC call using authenticated request
    const { data, error } = await makeAuthenticatedRequest(async () => {
      return await supabase.rpc('debug_user_auth');
    }, 'JWT transmission test');
    
    logger.debug('Test result:', logger.sanitizeForLog({
      data,
      error,
      currentToken: currentJWTToken ? 'SET' : 'NOT_SET'
    }));
    
    if (data && data.length > 0) {
      const result = data[0];
      logger.debug('Detailed analysis:', logger.sanitizeForLog({
        clerkIdFromFunction: result.clerk_id,
        jwtSubFromAuth: result.jwt_sub,
        authRole: result.auth_role,
        userExistsInDB: result.user_exists
      }));
    }
    
    return { data, error };
  } catch (error) {
    logger.error('JWT transmission test failed:', error);
    return { data: null, error };
  }
};

// Function to create authenticated storage client
export const createAuthenticatedStorageClient = () => {
  if (!currentJWTToken) {
    logger.warn('No JWT token available for storage');
    return supabase.storage;
  }

  logger.debug('Using authenticated storage client');
  return supabase.storage;
};


// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { logger } from '@/utils/logger';
import { securityMonitor } from '@/utils/securityMonitor';
import { apiRateLimiter } from '@/utils/rateLimiter';
import { securityHeaders } from '@/utils/securityHeaders';

const SUPABASE_URL = "https://fnzloyyhzhrqsvslhhri.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZuemxveXloemhycXN2c2xoaHJpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5MzAyMjIsImV4cCI6MjA2NDUwNjIyMn0.xdlgb_amJ1fV31uinCFotGW00isgT5-N8zJ_gLHEKuk";

// Validate required environment variables
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  throw new Error('Missing required Supabase configuration. Please check your environment variables.');
}

// Store the current JWT token and refresh function
let currentJWTToken: string | null = null;
let tokenRefreshFunction: (() => Promise<string | null>) | null = null;
let clientInstance: any = null;
let enhancedTokenManager: any = null;

// Create a single Supabase client instance
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: false,
    autoRefreshToken: true,
    detectSessionInUrl: false,
    storage: typeof window !== 'undefined' ? window.localStorage : undefined,
  },
  global: {
    headers: {}
  }
});

// Function to set token refresh function from Clerk
export const setTokenRefreshFunction = (refreshFn: () => Promise<string | null>) => {
  tokenRefreshFunction = refreshFn;
};

// Function to set enhanced token manager
export const setEnhancedTokenManager = (manager: any) => {
  enhancedTokenManager = manager;
};

// Enhanced function to refresh JWT token with silent error handling
export const refreshJWTToken = async (): Promise<string | null> => {
  try {
    // Use enhanced token manager if available
    if (enhancedTokenManager?.refreshToken) {
      const newToken = await enhancedTokenManager.refreshToken(true);
      if (newToken) {
        currentJWTToken = newToken;
        return newToken;
      }
    }
    
    // Fallback to legacy token refresh
    if (!tokenRefreshFunction) {
      return currentJWTToken;
    }

    const newToken = await tokenRefreshFunction();
    
    if (newToken) {
      currentJWTToken = newToken;
      return newToken;
    } else {
      return currentJWTToken;
    }
  } catch (error) {
    // Silent error handling for token refresh
    return currentJWTToken;
  }
};

// Function to check if token is expired (enterprise-grade timing)
const isTokenExpired = (token: string): boolean => {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return true;
    
    const payload = JSON.parse(atob(parts[1]));
    const now = Math.floor(Date.now() / 1000);
    const buffer = 120; // 2 minutes buffer before expiration (enterprise standard)
    
    return payload.exp && (payload.exp - buffer) < now;
  } catch (e) {
    return true;
  }
};

// Enhanced function to set Clerk JWT token with validation
export const setClerkToken = async (token: string | null) => {
  try {
    if (token) {
      // Validate token format
      const parts = token.split('.');
      if (parts.length !== 3) {
        return false;
      }

      // Check if token is expired
      try {
        const payload = JSON.parse(atob(parts[1]));
        const now = Math.floor(Date.now() / 1000);
        if (payload.exp && payload.exp < now) {
          const refreshedToken = await refreshJWTToken();
          if (refreshedToken && refreshedToken !== token) {
            currentJWTToken = refreshedToken;
            return true;
          }
          return false;
        }
      } catch (e) {
        // If we can't decode the token, we'll still try to use it
      }

      currentJWTToken = token;
      return true;
    } else {
      currentJWTToken = null;
      return true;
    }
  } catch (error) {
    return false;
  }
};

// Function to get current JWT token
export const getCurrentJWTToken = () => currentJWTToken;

// Enhanced function to make authenticated requests with enterprise-grade error handling
export const makeAuthenticatedRequest = async <T>(
  operation: () => Promise<T>,
  operationType: string = 'unknown',
  maxRetries: number = 3
): Promise<T> => {
  // Apply security checks asynchronously to avoid blocking
  const userIdentifier = currentJWTToken ? 
    JSON.parse(atob(currentJWTToken.split('.')[1]))?.sub || 'unknown' : 
    'anonymous';
  
  // Check rate limits in background
  setTimeout(() => {
    const rateLimitResult = apiRateLimiter.checkLimit(userIdentifier);
    if (!rateLimitResult.allowed) {
      securityMonitor.logSecurityEvent({
        type: 'rate_limit_exceeded',
        identifier: userIdentifier,
        details: { operation: operationType, resetTime: rateLimitResult.resetTime },
        severity: 'medium'
      });
    }
  }, 0);
  let lastError: any = null;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // Enterprise-grade token validation - only refresh if truly expired
      if (!currentJWTToken) {
        await refreshJWTToken();
      } else if (isTokenExpired(currentJWTToken)) {
        await refreshJWTToken();
      }

      if (!currentJWTToken) {
        throw new Error('Please refresh the page to continue');
      }

      // Create or update client instance
      if (!clientInstance) {
        clientInstance = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
          auth: {
            persistSession: false,
            autoRefreshToken: false,
          },
          global: {
            headers: {
              'Authorization': `Bearer ${currentJWTToken}`,
              'apikey': SUPABASE_PUBLISHABLE_KEY
            }
          }
        });
      } else {
        // Update headers on existing client
        clientInstance.supabaseKey = SUPABASE_PUBLISHABLE_KEY;
        clientInstance.supabaseUrl = SUPABASE_URL;
        clientInstance.auth.headers = {
          'Authorization': `Bearer ${currentJWTToken}`,
          'apikey': SUPABASE_PUBLISHABLE_KEY
        };
      }
      
      const authenticatedClient = clientInstance;

      // Replace the global supabase instance temporarily
      const originalFrom = supabase.from.bind(supabase);
      const originalRpc = supabase.rpc.bind(supabase);
      
      // Override methods to use authenticated client
      (supabase as any).from = authenticatedClient.from.bind(authenticatedClient);
      (supabase as any).rpc = authenticatedClient.rpc.bind(authenticatedClient);
      
      try {
        const result = await operation();
        
        // Log successful operations asynchronously
        if (operationType !== 'unknown') {
          setTimeout(() => {
            securityMonitor.logSecurityEvent({
              type: 'suspicious_activity',
              identifier: userIdentifier,
              details: { operation: operationType, success: true },
              severity: 'low'
            });
          }, 0);
        }
        
        return result;
      } finally {
        // Restore original methods
        (supabase as any).from = originalFrom;
        (supabase as any).rpc = originalRpc;
      }
    } catch (error: any) {
      lastError = error;
      
      // Check if it's a JWT expired error and retry
      if ((error?.code === 'PGRST301' || error?.message?.includes('JWT expired') || error?.message?.includes('expired')) && attempt < maxRetries - 1) {
        await refreshJWTToken();
        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
        continue;
      }
      
      // For network errors, also retry
      if ((error?.message?.includes('fetch') || error?.message?.includes('network')) && attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
        continue;
      }
      
      // Don't retry other errors unless it's the first attempt and token-related
      if (!error?.message?.includes('JWT') && !error?.code?.includes('PGRST301') && attempt > 0) {
        throw error;
      }
    }
  }
  
  // Convert technical errors to user-friendly messages
  if (lastError?.message?.includes('JWT') || lastError?.code === 'PGRST301') {
    throw new Error('Please refresh the page to continue');
  }
  
  throw lastError || new Error(`Operation failed after ${maxRetries} attempts`);
};

// Function to test JWT transmission
export const testJWTTransmission = async () => {
  try {
    const { data, error } = await makeAuthenticatedRequest(async () => {
      return await supabase.rpc('debug_user_auth');
    }, 'JWT transmission test');
    
    return { data, error };
  } catch (error) {
    return { data: null, error };
  }
};

// Function to create authenticated storage client
export const createAuthenticatedStorageClient = () => {
  if (!currentJWTToken) {
    return supabase.storage;
  }
  return supabase.storage;
};

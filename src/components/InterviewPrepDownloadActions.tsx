import { Button } from '@/components/ui/button';
import { Download, Copy } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import jsPDF from 'jspdf';
import { Document, Packer, Paragraph, TextRun } from 'docx';
import { saveAs } from 'file-saver';

interface InterviewPrepDownloadActionsProps {
  interviewData: string;
  jobTitle: string;
  companyName: string;
  contrast?: boolean;
}

const InterviewPrepDownloadActions = ({
  interviewData,
  jobTitle,
  companyName,
  contrast = false,
}: InterviewPrepDownloadActionsProps) => {
  const { toast } = useToast();

  const copyToClipboard = () => {
    navigator.clipboard.writeText(interviewData);
    toast({
      title: "Copied!",
      description: "Interview prep copied to clipboard."
    });
  };

  const handleDownloadPDF = () => {
    if (!interviewData) return;
    try {
      const doc = new jsPDF();
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const margin = 20;
      const maxWidth = pageWidth - (margin * 2);
      let yPosition = margin;

      // Helper function to add a new page if needed
      const checkPageBreak = (lineHeight: number = 6) => {
        if (yPosition + lineHeight > pageHeight - margin) {
          doc.addPage();
          yPosition = margin;
        }
      };

      // Helper function to add text with proper formatting
      const addFormattedText = (text: string, fontSize: number = 10, isBold: boolean = false, color: string = '#000000') => {
        doc.setFontSize(fontSize);
        doc.setFont('helvetica', isBold ? 'bold' : 'normal');
        doc.setTextColor(color);
        
        const lines = doc.splitTextToSize(text, maxWidth);
        
        for (let i = 0; i < lines.length; i++) {
          checkPageBreak(fontSize / 2);
          doc.text(lines[i], margin, yPosition);
          yPosition += fontSize / 2;
        }
        yPosition += 3; // Add some spacing after text blocks
      };

      // Header
      addFormattedText('Interview Preparation Guide', 18, true, '#1e40af');
      addFormattedText(`${jobTitle} at ${companyName}`, 14, false, '#374151');
      addFormattedText(`Generated on: ${new Date().toLocaleDateString()}`, 10, false, '#6b7280');
      yPosition += 10;

      // Process the interview data line by line
      const lines = interviewData.split('\n').filter(line => line.trim());
      
      for (const line of lines) {
        const trimmedLine = line.trim();
        
        if (!trimmedLine) {
          yPosition += 3;
          continue;
        }

        // Handle different markdown elements with specific colors for headings
        if (trimmedLine.startsWith('# ')) {
          // Main heading
          yPosition += 5;
          addFormattedText(trimmedLine.replace('# ', ''), 16, true, '#1e40af');
        } else if (trimmedLine.startsWith('## ')) {
          // Section heading
          yPosition += 5;
          addFormattedText(trimmedLine.replace('## ', ''), 14, true, '#2563eb');
        } else if (trimmedLine.startsWith('### ')) {
          // Sub-section heading
          yPosition += 3;
          addFormattedText(trimmedLine.replace('### ', ''), 12, true, '#3b82f6');
        } else if (trimmedLine.includes('**Question') && trimmedLine.includes(':**')) {
          // Question headers - Blue color
          const cleanText = trimmedLine.replace(/\*\*(.*?)\*\*/g, '$1');
          yPosition += 3;
          addFormattedText(cleanText, 11, true, '#2563eb');
        } else if (trimmedLine.includes('**Your Answer:**')) {
          // Your Answer headers - Green color
          const cleanText = trimmedLine.replace(/\*\*(.*?)\*\*/g, '$1');
          yPosition += 3;
          addFormattedText(cleanText, 11, true, '#16a34a');
        } else if (trimmedLine.includes('**Pro Tip:**')) {
          // Pro Tip headers - Orange color
          const cleanText = trimmedLine.replace(/\*\*(.*?)\*\*/g, '$1');
          yPosition += 3;
          addFormattedText(cleanText, 11, true, '#ea580c');
        } else if (trimmedLine.startsWith('**') && trimmedLine.endsWith('**')) {
          // Other bold text
          const cleanText = trimmedLine.replace(/\*\*/g, '');
          addFormattedText(cleanText, 10, true, '#374151');
        } else if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('• ')) {
          // Bullet points
          const bulletText = trimmedLine.replace(/^- |^• /, '• ');
          addFormattedText(bulletText, 10, false, '#374151');
        } else {
          // Regular text
          const cleanText = trimmedLine.replace(/\*\*(.*?)\*\*/g, '$1'); // Remove any remaining markdown
          addFormattedText(cleanText, 10, false, '#374151');
        }
      }

      // Footer
      checkPageBreak(20);
      yPosition = pageHeight - 30;
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor('#6b7280');
      doc.text('Generated by AI Interview Prep Assistant', margin, yPosition);
      doc.text(`Page ${doc.getNumberOfPages()}`, pageWidth - margin - 20, yPosition);

      doc.save(`Interview_Prep_${companyName.replace(/[^a-zA-Z0-9]/g, '_')}_${jobTitle.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`);
      
      toast({
        title: "Downloaded!",
        description: "Interview prep downloaded as PDF successfully.",
      });
    } catch (err) {
      console.error('PDF generation error:', err);
      toast({
        title: "Error",
        description: "Failed to download PDF. Please try again.",
        variant: "destructive",
      });
    }
  };

  const handleDownloadDOCX = async () => {
    if (!interviewData) return;
    try {
      // Parse the interview data into structured content
      const lines = interviewData.split('\n').filter(line => line.trim());
      const docChildren: Paragraph[] = [];

      // Add title
      docChildren.push(new Paragraph({
        children: [
          new TextRun({
            text: "Interview Preparation Guide",
            bold: true,
            size: 32,
            color: "1e40af",
          }),
        ],
      }));

      docChildren.push(new Paragraph({
        children: [
          new TextRun({
            text: `${jobTitle} at ${companyName}`,
            size: 24,
            color: "374151",
          }),
        ],
      }));

      docChildren.push(new Paragraph({
        children: [
          new TextRun({
            text: `Generated on: ${new Date().toLocaleDateString()}`,
            size: 20,
            color: "6b7280",
          }),
        ],
      }));

      docChildren.push(new Paragraph({ children: [new TextRun({ text: "" })] })); // Empty line

      // Process each line with specific colors for headings
      lines.forEach(line => {
        const trimmedLine = line.trim();
        
        if (!trimmedLine) {
          docChildren.push(new Paragraph({ children: [new TextRun({ text: "" })] }));
          return;
        }

        if (trimmedLine.startsWith('# ')) {
          docChildren.push(new Paragraph({
            children: [
              new TextRun({
                text: trimmedLine.replace('# ', ''),
                bold: true,
                size: 28,
                color: "1e40af",
              }),
            ],
          }));
        } else if (trimmedLine.startsWith('## ')) {
          docChildren.push(new Paragraph({
            children: [
              new TextRun({
                text: trimmedLine.replace('## ', ''),
                bold: true,
                size: 24,
                color: "2563eb",
              }),
            ],
          }));
        } else if (trimmedLine.startsWith('### ')) {
          docChildren.push(new Paragraph({
            children: [
              new TextRun({
                text: trimmedLine.replace('### ', ''),
                bold: true,
                size: 22,
                color: "3b82f6",
              }),
            ],
          }));
        } else if (trimmedLine.includes('**Question') && trimmedLine.includes(':**')) {
          // Question headers - Blue color
          const cleanLine = trimmedLine.replace(/\*\*/g, '');
          docChildren.push(new Paragraph({
            children: [
              new TextRun({
                text: cleanLine,
                bold: true,
                size: 22,
                color: "2563eb",
              }),
            ],
          }));
        } else if (trimmedLine.includes('**Your Answer:**')) {
          // Your Answer headers - Green color
          const cleanLine = trimmedLine.replace(/\*\*/g, '');
          docChildren.push(new Paragraph({
            children: [
              new TextRun({
                text: cleanLine,
                bold: true,
                size: 22,
                color: "16a34a",
              }),
            ],
          }));
        } else if (trimmedLine.includes('**Pro Tip:**')) {
          // Pro Tip headers - Orange color
          const cleanLine = trimmedLine.replace(/\*\*/g, '');
          docChildren.push(new Paragraph({
            children: [
              new TextRun({
                text: cleanLine,
                bold: true,
                size: 22,
                color: "ea580c",
              }),
            ],
          }));
        } else if (trimmedLine.startsWith('**') && trimmedLine.endsWith('**')) {
          // Other bold text
          const cleanLine = trimmedLine.replace(/\*\*/g, '');
          docChildren.push(new Paragraph({
            children: [
              new TextRun({
                text: cleanLine,
                bold: true,
                size: 20,
                color: "374151",
              }),
            ],
          }));
        } else {
          // Regular content with inline formatting
          const parts = trimmedLine.split(/(\*\*.*?\*\*)/);
          const textRuns: TextRun[] = [];
          
          parts.forEach(part => {
            if (part.startsWith('**') && part.endsWith('**')) {
              textRuns.push(new TextRun({
                text: part.replace(/\*\*/g, ''),
                bold: true,
                size: 20,
              }));
            } else if (part.trim()) {
              textRuns.push(new TextRun({
                text: part,
                size: 20,
              }));
            }
          });
          
          if (textRuns.length > 0) {
            docChildren.push(new Paragraph({ children: textRuns }));
          }
        }
      });

      const doc = new Document({
        sections: [{
          properties: {},
          children: docChildren,
        }],
      });

      const blob = await Packer.toBlob(doc);
      const cleanCompanyName = companyName.replace(/[^a-zA-Z0-9]/g, '_');
      const cleanJobTitle = jobTitle.replace(/[^a-zA-Z0-9]/g, '_');
      saveAs(blob, `Interview_Prep_${cleanCompanyName}_${cleanJobTitle}.docx`);
      
      toast({
        title: "Downloaded!",
        description: "Interview prep downloaded as DOCX successfully.",
      });
    } catch (err) {
      console.error('DOCX generation error:', err);
      toast({
        title: "Error",
        description: "Failed to download DOCX. Please try again.",
        variant: "destructive",
      });
    }
  };

  const buttonClass = contrast
    ? "bg-white text-black border-2 border-white hover:bg-black hover:text-white hover:border-white"
    : "border bg-white text-black hover:bg-gray-100";

  return (
    <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
      <Button
        onClick={copyToClipboard}
        className={buttonClass + " flex items-center gap-2 px-4 py-2 w-full sm:w-auto"}
        variant={undefined}
        size="sm"
      >
        <Copy className="w-4 h-4" />
        Copy
      </Button>
      <Button
        onClick={handleDownloadPDF}
        className={buttonClass + " flex items-center gap-2 px-4 py-2 w-full sm:w-auto"}
        variant={undefined}
        size="sm"
      >
        <Download className="w-4 h-4" />
        PDF
      </Button>
      <Button
        onClick={handleDownloadDOCX}
        className={buttonClass + " flex items-center gap-2 px-4 py-2 w-full sm:w-auto"}
        variant={undefined}
        size="sm"
      >
        <Download className="w-4 h-4" />
        DOCX
      </Button>
    </div>
  );
};

export default InterviewPrepDownloadActions;
